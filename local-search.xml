<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS5310_final_project</title>
    <link href="/2024/07/23/CS5310-final-project/"/>
    <url>/2024/07/23/CS5310-final-project/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Image"><a href="#1-Image" class="headerlink" title="1. Image"></a>1. Image</h1><h2 id="Do-something-interesting-to-the-image"><a href="#Do-something-interesting-to-the-image" class="headerlink" title="Do something interesting to the image"></a>Do something interesting to the image</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">../bin/lab1 geraniums.ppm lab1.ppm<br></code></pre></td></tr></table></figure><p>First, I changed the order of green and red to try to output only the leaves, but there was some noise. To fix this issue, two ideas came to mind:</p><ol><li>Blur the original image first, then perform the color separation.</li><li>Use a method similar to shadow mapping’s Percentage-Closer Filtering (PCF), which reduces noise by<br>sampling a circle of surrounding kernels to compute weights when each point is sampled.<br>I can do this change in the last section, so leave this method right here.</li></ol><div style="display: flex; justify-content: center; align-items: center;">  <img src="1_1.jpg" title="Brief output of green leaves" width="300px" height="300px"></div><h2 id="Implement-green-blue-screen-compositing"><a href="#Implement-green-blue-screen-compositing" class="headerlink" title="Implement green&#x2F;blue screen compositing"></a>Implement green&#x2F;blue screen compositing</h2><p>Try to mask the blue and green channel, and try to combine it with the origin background, here is what I got.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">../bin/mask powerpuff.ppm mask.ppm<br></code></pre></td></tr></table></figure><div style="display: flex; justify-content: center; align-items: center;">  <img src="1_2.jpg" title="A regular image" width="200px" height="200px" >  <img src="1_3.jpg" title="A regular image" width="200px" height="200px"></div><p>Trying to use offset dx and dy now. </p><div style="display: flex; justify-content: center; align-items: center;">   <img src="1_4.jpg" title="A regular image" width="200px" height="200px"></div><p>But there are still two problems:</p><ul><li>The front image is so big, trying to add a scale funtion before combine.</li><li>The eyes are missing, because the current blue and green channel blocks much more than except.</li></ul><h3 id="add-scale"><a href="#add-scale" class="headerlink" title="add scale"></a>add scale</h3><p>A new scale function has been added, which now scale the size of the image, the command is below.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">../bin/combine powerpuff.ppm geraniums.ppm mask.ppm 20 -20 0.5 output.ppm<br></code></pre></td></tr></table></figure><div style="display: flex; justify-content: center; align-items: center;">   <img src="1_5.jpg" title="A regular image" width="200px" height="200px"></div><h3 id="updated-mask-algorithm"><a href="#updated-mask-algorithm" class="headerlink" title="updated mask algorithm"></a>updated mask algorithm</h3><p>After studying the image carefully, the eyes are composed of black and white, so I changed the algorithm so that if the color of the rgb is black, or pure white, it always counts as white and doesn’t count as part of the background. Now the result seems better.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">../bin/mask powerpuff.ppm mask.ppm<br></code></pre></td></tr></table></figure><div style="display: flex; justify-content: center; align-items: center;">  <img src="1_6.jpg" title="A regular image" width="200px" height="200px" >  <img src="1_7.jpg" title="A regular image" width="200px" height="200px"></div><h3 id="add-blur-background"><a href="#add-blur-background" class="headerlink" title="add blur background"></a>add blur background</h3><p>It feels like if you can blur the background, the result should be cool. My algorithm just adds a kernel just like the pcf in shadowmap and samples around the circle to average the blur. And below is my final result</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="1_8.jpg" title="A regular image" width="300px" height="300px" ></div><h2 id="Concolusion"><a href="#Concolusion" class="headerlink" title="Concolusion"></a>Concolusion</h2><p>After this assignment we’ve got the basic pixel, colour data structures, written all the relevant functions, the memory allocation for c has really bothered me for a long time, I’m relying too much on smart pointers, this class will give me a deeper understanding of stack and heap allocating memory and freeing it.</p><h1 id="2-Graphic-Primitives"><a href="#2-Graphic-Primitives" class="headerlink" title="2. Graphic Primitives"></a>2. Graphic Primitives</h1><p>This assignment explores the implementation of various fractal and noise generation algorithms using C and C++. The primary focus is on generating images of Mandelbrot and Julia sets, as well as creating cloud patterns using Perlin noise. The document details the challenges faced in integrating C and C++ code, particularly for functions specific to image processing requirements. Additionally, it includes animated visualizations of Julia sets and Perlin noise-based clouds, demonstrating the dynamic behavior of these mathematical constructs. The assignment emphasizes the importance of understanding underlying principles and efficient implementation techniques in computer graphics.</p><h2 id="Image-Structure"><a href="#Image-Structure" class="headerlink" title="Image Structure"></a>Image Structure</h2><p>This part the code I writed is totally in C, because some of the functions in the assignment requirements cannot be implemented in C++, they do not meet the requirements. Image.h can be called with c, or with C++’s extern as below:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Image.h&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>The result as below:</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="2_1.jpg" title="A regular image" width="300px" height="200px" >  <img src="2_2.jpg" title="A regular image" width="300px" height="200px" >  <img src="2_3.jpg" title="A regular image" width="300px" height="200px"></div><p>I used to set the max_value as float [0,1] I found the reason why this doesnot work and cause a crash. At last I found that PPM (P6) set max_value as int [0,255] not as I except.</p><h2 id="Mandelbrot-and-Julia-Sets"><a href="#Mandelbrot-and-Julia-Sets" class="headerlink" title="Mandelbrot and Julia Sets"></a>Mandelbrot and Julia Sets</h2><p>based on the requirement below: </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">A picture of the complete Mandelbrot set in an appropriate rectangle.<br>A picture of a Julia set defined by c = 0.7454054 + i*0.1130063 in an appropriate rectangle.<br></code></pre></td></tr></table></figure><p>The assignment didn’t involve considering colors, so the result as below.</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="2_4.jpg" title="A regular image" width="300px" height="200px" >  <img src="2_5.jpg" title="A regular image" width="300px" height="200px" >  <img src="2_6.jpg" title="A regular image" width="300px" height="200px"></div><p>Here are something I wanna mentioned:  </p><ol><li>I change the <code>mandeltest.c</code>to <code>mandeltest.cpp</code>, because the implantation of <code>fractals.cpp/h</code> I use c++.</li><li>Normal equation of this two method to update z is $z^2 + c$ , but the lab instruction is $z^2 - c$. I choose to use the lab instruction.</li><li>To conform to the coordinate system required for the assignment, I inverted my y-axis.</li></ol><h3 id="add-something-I-am-interested-in-ImageMagick"><a href="#add-something-I-am-interested-in-ImageMagick" class="headerlink" title="add something I am interested in : ImageMagick"></a>add something I am interested in : ImageMagick</h3><p>I wanna to see the movement of julia function like output a video, there are two method comes to my mind : 1. build a graphic pipeline or output lots of ppm and combine them as a JIF. I am too lasy to select the second method. Click the figure below can jump to the website I store the GIF.</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="2_11.gif" title="A regular image" width="900px" height="500px" ></div><h2 id="Fractal-Noise-Perlin"><a href="#Fractal-Noise-Perlin" class="headerlink" title="Fractal Noise: Perlin"></a>Fractal Noise: Perlin</h2><h3 id="single-level-Perlin"><a href="#single-level-Perlin" class="headerlink" title="single-level Perlin"></a>single-level Perlin</h3><p>Generates a cloud pattern using a single-level Perlin noise algorithm and applies it to an image. In my main.cpp it is generateCloudsPerlin.</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="2_8.jpg" title="A regular image" width="300px" height="200px" ></div><h3 id="multi-level-Perlin"><a href="#multi-level-Perlin" class="headerlink" title="multi-level Perlin"></a>multi-level Perlin</h3><p>Generates a cloud pattern using a multi-level Perlin noise algorithm and applies it to an image. In my <code>main.cpp</code> it is <code>generateCloudsPerlin2</code>.</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="2_12.gif" title="A regular image" width="900px" height="500px" ></div><h2 id="animation-of-sky-and-cloud"><a href="#animation-of-sky-and-cloud" class="headerlink" title="animation of sky and cloud"></a>animation of sky and cloud</h2><p>Generates a cloud pattern using a multi-level Perlin noise algorithm with time-based animation and distinguishes between cloud and sky regions. In my main.cpp it is <code>generateCloudsPerlin4</code>.</p><div style="display: flex; justify-content: center; align-items: center;">  <img src="2_13.gif" title="A regular image" width="900px" height="500px" ></div><h1 id="Water-Simulation"><a href="#Water-Simulation" class="headerlink" title="Water Simulation"></a>Water Simulation</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>After assignment Lighting and Shading, we already have light, so it is time for me to start building the surface of the sea.</p><h2 id="Mesh-the-water-surface"><a href="#Mesh-the-water-surface" class="headerlink" title="Mesh the water surface"></a>Mesh the water surface</h2><p>I made a 50 x 50 size mesh in xz plane, and each set have four points, combine as a polygon, all the normal of polygon initialize as 0,1,0, which is up.</p><p><img src="/2024/07/23/CS5310-final-project/10.jpg"></p><h2 id="Simulation-the-water-by-Sinusoids-Wave"><a href="#Simulation-the-water-by-Sinusoids-Wave" class="headerlink" title="Simulation the water by Sinusoids Wave"></a>Simulation the water by Sinusoids Wave</h2><p>$h(x, z, t) &#x3D; -y_0 + \sum_{i&#x3D;1}^{N_w} A_i \cos(k_{ix} x + k_{iz} z - \omega_i t)$   </p><p>$h(x,z,t)$ : the height y of the wave when time t and position (x,z).<br>$Nw$: total number of waves.<br>$Ai$: each wave’s amplitude.</p><p>Depth Shading and Ground Shading in real time below.</p><p><img src="/2024/07/23/CS5310-final-project/2.gif" alt="Depth Shading + Sinusoids Wave"></p><p><img src="/2024/07/23/CS5310-final-project/3.gif" alt="Ground Shading + Sinusoids Wave"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Basic Computer Graphic Algorithm</title>
    <link href="/2024/07/04/Basic-Computer-Graphic-Algorithm/"/>
    <url>/2024/07/04/Basic-Computer-Graphic-Algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="z-buffer-rendering"><a href="#z-buffer-rendering" class="headerlink" title="z-buffer rendering"></a>z-buffer rendering</h2><p>一种隐藏面消除技术，记录每个像素的深度值来决定哪个项目应该在前面。对于z来说，1.0表示最远，0.0最近。但我们一般用$\frac{1}{z}$，因为透视投影的线段zbuffer变化并非线性。</p><ol><li>backplane depth(后平面深度): 三维渲染之中最远可以看到的平面，和透视矩阵中最远的平面far plane一个意思。</li><li>z value初始化要设置为1.0而不是0, 在我们进行z-buffer rendering之前所有的物体距离我们最远。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/29/hello-world/"/>
    <url>/2023/11/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UE5 source code reading node</title>
    <link href="/2023/10/20/UE5_source_code_analysis/"/>
    <url>/2023/10/20/UE5_source_code_analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="blueprint-global"><a href="#blueprint-global" class="headerlink" title="blueprint global"></a>blueprint global</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>D3D12_learning_notes</title>
    <link href="/2023/10/18/D3D12-learning-notes/"/>
    <url>/2023/10/18/D3D12-learning-notes/</url>
    
    <content type="html"><![CDATA[<h1 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h1><ol><li>fully understand the meaning of each compoents</li><li>fully write the code of Hello World</li><li>build a ray casting</li><li>build a defered rendering</li></ol><h1 id="graphics-pipeline-in-DirectX-12"><a href="#graphics-pipeline-in-DirectX-12" class="headerlink" title="graphics pipeline in DirectX 12."></a>graphics pipeline in DirectX 12.</h1><p><img src="/2023/10/18/D3D12-learning-notes/3.png"></p><ol><li>Fixed-function stages (blue): cannot change how they process data, but can configure them using the DirectX 12 API. Such as imachines in a factory.</li><li>Programmable stages(green): can write a shadow program like HLSL to define exactly how data is processed. Such as a program a robot in a factory.</li></ol><ul><li><p>Input-Assembler(IA) stage: read primitive data from user-defined vertex and index buffers and assemble that data into geometric primitives.</p></li><li><p>Vertex Shader(VS) Stage<br>transform the vertex data from object-space into clip-space.</p></li><li><p>Hull Shader(HS) Stage<br>It is responsible for determining how much an input control patch should be tessellated by the tesslation.</p></li></ul><h1 id="basics-of-D3D12"><a href="#basics-of-D3D12" class="headerlink" title="basics of D3D12"></a>basics of D3D12</h1><p>Globaly learning DirectX. </p><h2 id="useful-functions"><a href="#useful-functions" class="headerlink" title="useful functions"></a>useful functions</h2><ol><li>IDXGI Factory (DirectX Graphic Infrastructure)<br>Enum Adapters and Creating Swap Chain<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">GRS_THROW_IF_FAILED</span>(<span class="hljs-built_in">CreateDXGIFactory2</span>(nDXGIFactoryFlags, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;pIDXGIFactory5)));<br></code></pre></td></tr></table></figure></li></ol><h2 id="creating-resources"><a href="#creating-resources" class="headerlink" title="creating resources"></a>creating resources</h2><h3 id="CreateCommittedResouce"><a href="#CreateCommittedResouce" class="headerlink" title="CreateCommittedResouce"></a>CreateCommittedResouce</h3><p>implicit heap: the heap object can’t be obtained by the application. Just call the heap and use it directly, do not need to build the heap manually. But hard to control the detail of the heap.</p><h3 id="CreatePlacedResource"><a href="#CreatePlacedResource" class="headerlink" title="CreatePlacedResource"></a>CreatePlacedResource</h3><h3 id="CreatReservedResource"><a href="#CreatReservedResource" class="headerlink" title="CreatReservedResource"></a>CreatReservedResource</h3><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">D3D12_HEAP_TYPE</span><br>&#123;<br>    D3D12_HEAP_TYPE_DEFAULT            = <span class="hljs-number">1</span>, <br>    D3D12_HEAP_TYPE_UPLOAD             = <span class="hljs-number">2</span>,<br>    D3D12_HEAP_TYPE_READBACK           = <span class="hljs-number">3</span>,<br>    D3D12_HEAP_TYPE_CUSTOM              = <span class="hljs-number">4</span><br>&#125; D3D12_HEAP_TYPE;<br></code></pre></td></tr></table></figure><ul><li>DEFAULT: creating buffet when D3Dxx_USAGE &#x3D; Default, only GPU  could access the data, CPU can not directly access the data. Which means it usually in $\textbf{video memory}$. Always insert some data hard to change in it, such as texture. </li><li>UPLOAD: GPU can not load the data, so upload heap is using to load the data in DEFAULT heap. For GPU “read only”, For CPU “write only”. For do not change.</li><li>READBACK: the oppsite of UPLOAD</li></ul><h2 id="Resource-Barrier"><a href="#Resource-Barrier" class="headerlink" title="Resource Barrier"></a>Resource Barrier</h2><p>Handle the parallelism problem between copy engine and graphic command engine. Ep. The texture is large enough and $\textbf{memcopy}$ need some time to copy. But the graphic command engine do not know that and already start $\textbf{Draw Call}$ the texture, which lead the unfinished texture to be rendered.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//send the command to the command heap of copy something from UPLOAD heap to DEFAULT heap</span><br><span class="hljs-function">CD3DX12_TEXTURE_COPY_LOCATION <span class="hljs-title">Dst</span><span class="hljs-params">(pITexcute.Get(), <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">CD3DX12_TEXTURE_COPY_LOCATION <span class="hljs-title">Src</span><span class="hljs-params">(pITextureUpload.Get(), stTxtLayouts)</span></span>;<br><br><span class="hljs-comment">// directly command a list&#x27;s object.</span><br>pICommandList-&gt;<span class="hljs-built_in">CopyTextureRegion</span>(&amp;Dst, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;Src, <span class="hljs-literal">nullptr</span>);<br> <br><span class="hljs-comment">// Resource Barrier</span><br>D3D12_RESOURCE_BARRIER stResBar = &#123;&#125;;<br>stResBar.Type= D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;<br>stResBar.Flags= D3D12_RESOURCE_BARRIER_FLAG_NONE;<br>stResBar.Transition.pResource= pITexcute.<span class="hljs-built_in">Get</span>();<br>stResBar.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;<br>stResBar.Transition.StateAfter= D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;<br>stResBar.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;<br> <br>pICommandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<span class="hljs-number">1</span>, &amp;stResBar);<br></code></pre></td></tr></table></figure><p>In my understanding, because command heap’s excution on GPU is in serial order, which means rescource barrier is just like crossbars at supermarket checkout counters.</p><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>used to looking for a adapter(graphic card)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ComPtr&lt;IDXGIAdapter4&gt; <span class="hljs-title">GetAdapter</span><span class="hljs-params">(<span class="hljs-type">bool</span> useWarp)</span></span><br><span class="hljs-function"></span>&#123;<br>    ComPtr&lt;IDXGIFactory4&gt; dxgiFactory;<br>    UINT createFactoryFlags = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_DEBUG)</span><br>    createFactoryFlags = DXGI_CREATE_FACTORY_DEBUG;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br>    <span class="hljs-built_in">ThrowIfFailed</span>(<span class="hljs-built_in">CreateDXGIFactory2</span>(createFactoryFlags, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;dxgiFactory)));<br>   ComPtr&lt;IDXGIAdapter1&gt; dxgiAdapter1;<br>    ComPtr&lt;IDXGIAdapter4&gt; dxgiAdapter4;<br><br>    <span class="hljs-keyword">if</span> (useWarp)<br>    &#123;<br>        <span class="hljs-built_in">ThrowIfFailed</span>(dxgiFactory-&gt;<span class="hljs-built_in">EnumWarpAdapter</span>(<span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;dxgiAdapter1)));<br>        <span class="hljs-built_in">ThrowIfFailed</span>(dxgiAdapter1.<span class="hljs-built_in">As</span>(&amp;dxgiAdapter4));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SIZE_T maxDedicatedVideoMemory = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; dxgiFactory-&gt;<span class="hljs-built_in">EnumAdapters1</span>(i, &amp;dxgiAdapter1) != DXGI_ERROR_NOT_FOUND; ++i)<br>        &#123;<br>            DXGI_ADAPTER_DESC1 dxgiAdapterDesc1;<br>            dxgiAdapter1-&gt;<span class="hljs-built_in">GetDesc1</span>(&amp;dxgiAdapterDesc1);<br> <br>            <span class="hljs-comment">// Check to see if the adapter can create a D3D12 device without actually </span><br>            <span class="hljs-comment">// creating it. The adapter with the largest dedicated video memory</span><br>            <span class="hljs-comment">// is favored.</span><br>            <span class="hljs-keyword">if</span> ((dxgiAdapterDesc1.Flags &amp; DXGI_ADAPTER_FLAG_SOFTWARE) == <span class="hljs-number">0</span> &amp;&amp;<br>                <span class="hljs-built_in">SUCCEEDED</span>(<span class="hljs-built_in">D3D12CreateDevice</span>(dxgiAdapter1.<span class="hljs-built_in">Get</span>(), <br>                    D3D_FEATURE_LEVEL_11_0, __uuidof(ID3D12Device), <span class="hljs-literal">nullptr</span>)) &amp;&amp; <br>                dxgiAdapterDesc1.DedicatedVideoMemory &gt; maxDedicatedVideoMemory )<br>            &#123;<br>                maxDedicatedVideoMemory = dxgiAdapterDesc1.DedicatedVideoMemory;<br>                <span class="hljs-built_in">ThrowIfFailed</span>(dxgiAdapter1.<span class="hljs-built_in">As</span>(&amp;dxgiAdapter4));<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> dxgiAdapter4;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Command-List-Command-Allocator-Command-Queue"><a href="#Command-List-Command-Allocator-Command-Queue" class="headerlink" title="Command List, Command Allocator, Command Queue"></a>Command List, Command Allocator, Command Queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// DirectX 12 Objects</span><br>ComPtr&lt;ID3D12Device2&gt; g_Device;<br>ComPtr&lt;ID3D12CommandQueue&gt; g_CommandQueue;<br>ComPtr&lt;IDXGISwapChain4&gt; g_SwapChain;<br>ComPtr&lt;ID3D12Resource&gt; g_BackBuffers[g_NumFrames];<br>ComPtr&lt;ID3D12GraphicsCommandList&gt; g_CommandList;<br>ComPtr&lt;ID3D12CommandAllocator&gt; g_CommandAllocators[g_NumFrames];<br>ComPtr&lt;ID3D12DescriptorHeap&gt; g_RTVDescriptorHeap;<br>UINT g_RTVDescriptorSize;<br>UINT g_CurrentBackBufferIndex;<br></code></pre></td></tr></table></figure><ul><li><p>Comptr: it goes out of scope when COM object is no longer needed, helping to prevent memory leaks.</p></li><li><p>CommandAllocator: create and manage the memory that backs(supports) command list. Every command list need a command allocator, and each command allocator can be used with one command list at a time.</p></li><li><p>Command List: CPU records a list of commands to be executed by GPU. Such as state changes, resource barriers, drawing operations…</p></li><li><p>Command Queue: An interface through which CPU submits the recorded command lists to the GPU for execution. The GPU start excute the command as soon as CPU put command list in it.</p></li></ul><h2 id="Fence"><a href="#Fence" class="headerlink" title="Fence"></a>Fence</h2><p><img src="/2023/10/18/D3D12-learning-notes/6.png"><br>A marker let you know when GPU has finished doing its work and tell CPU, so they can be synchronised.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Synchronization objects</span><br><span class="hljs-comment">// a pointer used to ensure the synchronization primitive that the CPU can use to determine the eprogress of the GPU&#x27;s execution of command lists.</span><br>ComPtr&lt;ID3D12Fence&gt; g_Fence;<br><span class="hljs-comment">// the next fence value to signal the command queue</span><br><span class="hljs-type">uint64_t</span> g_FenceValue = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// each frame could be &#x27;in-flight&#x27; on the command queue, this is used to keep tracked to guarantee that any resources that are still being referenced by the command queue are not overwritten.</span><br><span class="hljs-type">uint64_t</span> g_FrameFenceValues[g_NumFrames] = &#123;&#125;;<br><span class="hljs-comment">// used to hold on untill the fance has reached a specific value.</span><br>HANDLE g_FenceEvent;<br></code></pre></td></tr></table></figure><h2 id="Swap-Chain"><a href="#Swap-Chain" class="headerlink" title="Swap Chain"></a>Swap Chain</h2><p><img src="/2023/10/18/D3D12-learning-notes/4.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">unit8_t</span> g_NumFrames = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>must more than 2 if using flip ppresentation model.</p><h2 id="Transformation-Pipeline"><a href="#Transformation-Pipeline" class="headerlink" title="Transformation Pipeline"></a>Transformation Pipeline</h2><ol><li>World Transform: change each 3D model’s coordinates into world coordinates.</li><li>View Transform: $V &#x3D; T \cdot R_z \cdot R_y \cdot R_z$</li><li>Projection Transform:</li></ol><p><img src="/2023/10/18/D3D12-learning-notes/1.png"><br><img src="/2023/10/18/D3D12-learning-notes/2.png"></p><ol start="4"><li>Clip transform: ignore the part not in the camera.</li></ol><h2 id="Render-Target-View-RTV"><a href="#Render-Target-View-RTV" class="headerlink" title="Render Target View(RTV):"></a>Render Target View(RTV):</h2><p>The purpose of it is just tell GPU how to render at back buffer before swap. If without RTV, the GPU will not know where the rendered pixel should be sent.<br><img src="/2023/10/18/D3D12-learning-notes/5.png"></p><h1 id="glossary-of-CG"><a href="#glossary-of-CG" class="headerlink" title="glossary of CG"></a>glossary of CG</h1><ul><li><p>mipmap: a set of pictures, with different level of pixels. Becasue off-site viewing do not need that detailed.</p></li><li><p>SRV(shader resource view): wrapping textures in a format that the shadow can access them. Read Only. For example : a single texture, individual arrays, planes, or colors from a mipmapped texture, 3D texture, 1D texture color gradinets, etc.</p></li><li><p>UAV(unordered access view): same as SRV, but can read or write in any order, even could read&#x2F;written simultaneously by multipl,e threads without generate memory conflicts.</p></li><li><p>root signatures: link command to the resources the shaders require. It determines the type of data the shaders should expect, but does not define the actural memory or data. For graphics command list has both a graphics and compute root signature, for compute command list have one compute root signature. These root signatures are independent of each others.</p></li><li><p>Resource: all the resource could be excuted by GPU is resource in D3D12. Which is ‘ID3D12Resource’, such as rendering targets(include back buffers), textures, vertex buffers, index buffers… </p></li><li><p>G-SYNC: refresh screen and graph card together.</p></li><li><p>Window Advanced Rasterization Platform(WARP): If did not find a valiable GPU, the system will do the same step of D3D12 by CPU by WARP. It can instead all the rendering method such as rasterization, ray tracing…</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
